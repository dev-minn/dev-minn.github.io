---
title:  "Chapter 3. 데코레이터 패턴" 

categories:
  -  Design Pattern
tags:
  - [Design Pattern]

toc: true
toc_sticky: true

date: 2023-09-14
---


## 📌 데코레이터패턴

> 💡 <b>디자인 원칙</b>
> - OCP(Open-Closed Principle)
> - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 함
{: .notice--info}

<br>

- 객체에 추가 요소를 동적으로 더할 수 있음
- 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있음  
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같음
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있음
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관없음
- <b>데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있음</b>
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있음
- 데코레이터 순선느 원본 대상 객체 생성자를 장식자 생성자가 Wrapping 하는 형태로 간다고 보면 됨
    - new 장식자(new 원본())
- 디자인의 유연성 면에서 보면 상속으로 확장하는 일은 별로 좋은 선택은 아님
- 기존 코드 수정 없이 행동을 확장해야 하는 상황도 있음
- 구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있음
- 상속 대신 데코레이터 패턴으로 행동을 확장할 수 있음
- 데코레이터 패턴은 구상 구성요소를 감싸 주는 데코레이터를 사용
- 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영
- 상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가짐
- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장함
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없음
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없음
- 클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외
- 데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해짐

<br>

## 📌 사용시기

- 객체 책임과 행동이 동적으로 상황에 따라 다양한 기능이 빈번하게 추가/삭제 되는 경우
- 객체의 결합을 통해 기능이 생성될 수 있는 경우
- 객체를 사용하는 코드를 손상시키지 않고 런타임에 객체에 추가 동작을 할당할 수 있어야 하는 경우
- 상속을 통해 서브클래싱으로 객체의 동작을 확장하는 것이 어색하거나 불가능 할 때

<br>

## 📌 장점

- 데코레이터를 사용하면 서브클래스를 만들때 보다 훨씬 더 유연하게 기능을 확장할 수 있음
- 객체를 여러 데코레이터로 래핑하여 여러 동작을 결합할 수 있음
- 컴파일 타임이 아닌 런타임에 동적으로 기능을 변경할 수 있음
- 각 장식자 클래스마다 고유의 책임을 가져 단일책임원칙 준수
    - 단일책임원칙(SRP - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행)
- 클라이언트 코드 수정없이 기능 확장이 필요하면 장식자 클래스를 추가하면 되니 준수 
    - 개방폐쇄원칙(OCP - 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계)
- 구현체가 아닌 인터페이스를 바라봄으로써 의존역전원칙 준수
    - 의존역전원칙(DIP - 클래스를 참조할 때 직접 참조하는 것이 아니라 그 대상의 상위요소[추상클래스/인터페이스]로 참조)

<br>

## 📌 단점

- 만일 장식자 일부를 제거하고 싶다면, Wrapper 스택에서 특정 Wrapper 를 제거하는 것은 어려움
- 데코레이터를 조합하는 초기 생성코드가 보기 안 좋을 수 있음
    - new A(new B(new C(new D())))
- 어느 장식자를 먼저 데코레이팅 하느냐에 따라 데코레이터 스택 순서가 결정지게 되는데, 만일 순서에 의존하지 않는 방식으로 데코레이터를 구현하기는 어려움

<br>

## 📌 예제

> 💡 <b>데코레이터패턴 예제</b>
>
>  - Data 클래스를 멀티쓰레드 환경에서도 사용할 수 있도록 동기화 처리
{: .notice--info}

<br>

### 패턴 구현

